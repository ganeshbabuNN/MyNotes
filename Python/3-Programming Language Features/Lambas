
1.Introduction
2.lamba - cube of given number
3.lamba - even or odd
4.lambda - sum of two number
5.using filter
6.using map function
7.using reduce function
8.decorators
9.decorator that doubles the results of function
10.using @Decorator
11.Decorator string
12.generators
13.create a generators
14.create a module and use it
15.different ways to import

1.Introduction
=============
-it a funciton does not have any name.whch is also called as anonymous function

sytax:
lambda argument_list:expression

-it need to return a function 

2.lamba - cube of given number
=============================

f=lambda n:n**3
print f(3)

3.lamba - even or odd
======================

f=lambda x: 'Yes' if x%2==0 else 'No'
print f(3)

4.lambda - sum of two number
============================
f=lambda a,b:a+b
print f(3,4)

5.using filter
=============
-The filter() method filters the given sequence with the help of a function that tests each element in the sequence to be true or not.
-filter is a lambda expression
--it generally iterate each item and returns those filter values using lambdas expression

lst =[24,111,11,32,6,8,9]
result =filter(lambda x:x%2==0, lst) 
print result
for i in result: print i

6.Using map function
====================
-map() function returns a map object(which is an iterator) of the results after applying the given function to each item of a given iterable (list, tuple etc.)
-it generally iterate each item and returns each items values by the lamba express.

lst =[24,111,11,32,6,8,9]
result =map(lambda x:x*2, lst) 
print result 

7.using reduce function
=======================
-The reduce(fun,seq) function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along.This function is defined in “functools” module
-it generally iterate each item and returns resulted value of the expression. its need min two as argument. we can perform aggregations operations.

Example:
import functools as ft
lst =[3,6,8,9]
result =ft.reduce(lambda x,y:x+y, lst) 
print result

8.decorators
============
-a function that performs additional logic which return by the function

9.decorator that doubles the results of function
================================================
#calling result of the functions
def decor(num):
    def inner():
        #
        result = num()
        return result*2
    return inner

#calling the functions
def cal():
    return 4

output=decor(cal) # argument must be a  function

print output()  # invoke the question


10.using @Decorator
===================
--using the @function name of the function which you are calling. it may be a funtion which are return

#calling result of the functions
def decor(num):
    def inner():
        # num() is equal to hello() result
        result = num()
        return result*2
    return inner

@decor
def hello():
    return 10

print hello()


11.Decorator string
===================
- decorator a string out the functions

def decorfun(fun):
    def inner(n):
        #fun(n) is equal to hello(name) result
        result = fun(n)
        result=result+ " how are you?"
        return result
    return inner
 
@decorfun   
def hello(name):
    return " hello " + name

print(hello("ganesh"))

12.generators
=============
-A generator-function is defined like a normal function, but whenever it needs to generate a value, it does so with the yield keyword rather than return. If the body of a def contains yield, the function automatically becomes a generator function.
-Generator functions return a generator object. Generator objects are used either by calling the next method on the generator object or using the generator object in a “for in” loop (as shown in the above program)ß

13.create a generators
======================

def customgen(x,y):
    while(x<y):
        yield x 
        x=x+1 

result = customgen(10, 15)
for i in result: print i

14.create a module and use it
=============================
-A module is a file containing Python definitions and statements. A module can define functions, classes and variables. A module can also include runnable code. Grouping related code into a module makes the code easier to understand and use.

create a module 
---------------
mymath.py

def add(x,y):
    return x+y

def diff(x,y):
    return x-y

create a file and call that module
----------------------------------
usesmodule.py

import mymath

print mymath.add(2,3)
print mymath.add(5,2)

15.different ways to import
===========================
1- provide a alias name

import mymath as ma

print ma.add(2,3)
print ma.add(5,2)

2-use from keyword which import all the functions and other from that modules  
from mymath import *