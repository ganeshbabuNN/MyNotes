intro 
how to group rows into subgroups and apply an aggregate function for each group
Filter a group of rows
how to generate multiple grouping sets in a query
Cross Tabluted reports

Intro
=====
-Performing a calculation with one or more variables over the whole data set is useful, but very often we also need to carry out an operation on different subsets of our data
-The group_by function provides a more elegant solution to this kind of problem
-It doesn’t do all that much on its own though
-All the group_by function does is add a bit of grouping information to a tibble or data frame

syntax:
	group_by(data_set, vname1, vname2, ...)


How to group rows into subgroups and apply an aggregate function for each group
===============================================================================

Grouping by various wise
------------------------
using dplyr
*--------*
summarise() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input.

group_by(storms,year) 
stroms_group <- group_by(storms,year)
#apply for the summarise functions
summarise(stroms_group,mean.wind=mean(wind))

#using the operator
storms %>%  group_by(year) %>% summarise(mean.wind=mean(wind))

grouping more than one variable
-------------------------------

using dplyr
*---------*
unique(storms$status)
stroms_grp <- group_by(storms,status,year)
summarise(stroms_grp,mean_wind=mean(wind),mean_pressure=mean(pressure))

#using the operator
storms %>%  group_by(status,year) %>% summarise(mean_wind=mean(wind),mean_pressure=mean(pressure))
          
Using group_by with other verbs
--------------------------------

using dplyr
*---------*
#The summarise function is the only dplyr verb we’ll use with grouped tibbles in this book
#When mutate or transmute are used with a grouped object they still add new variables, but now the calculations occur “by group”
stroms_grp <- group_by(storms,status)
stroms_grp
transmute(stroms_grp,wind_centered=wind-mean(wind))

#using the operator
storms %>%  group_by(status) %>% transmute(wind_centered=wind-mean(wind)) %>% unique()

Removing grouping information
-----------------------------

using dplyr
*---------*
ungroup(stroms_grp)

Filter a group of rows
======================

storms %>% group_by(status) %>% summarise(mn_mean=mean(wind),n=n()) %>% filter(mn_mean >30) %>% select(status,mn_mean) %>% arrange(status)

How to generate multiple grouping sets in a query
=================================================
Aggregate is a function in base R which can, as the name suggests, aggregate the inputted data.frame d.f by applying a function specified by the FUN parameter to each column of sub-data.frames defined by the by input parameter

#getting summary of all numerical variables in a grouping way
library(dplyr)
aggregate(cbind(wind,pressure,month,day,hour)~status,data=storms,FUN=mean)    


..ctd

Quiz
====

Assignment
==========


Resources:
=========
https://towardsdatascience.com/grouping-data-with-r-ef95cee48dc6
https://dzchilds.github.io/eda-for-bio/grouping-and-summarising-data.html#getting-ready-2
https://www.red-gate.com/simple-talk/development/dotnet-development/data-manipulation-in-r-beyond-sql/
https://dplyr.tidyverse.org/reference/group_by.html
https://www3.nd.edu/~steve/computing_with_data/24_dplyr/dplyr.html
https://tidyr.tidyverse.org/articles/pivot.html#string-data-in-column-names