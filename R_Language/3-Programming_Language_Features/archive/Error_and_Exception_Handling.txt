Error
Expections
Exception Handling Constructs in R
Quiz
Assigment
Resources

Error
====
Syntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning R

let see some different type of error

ex:
SyntaxError
-----------
'hello world' + 3

IndexError
ModuleNotFoundError
KeyError
ImportError
TypeError
ValueError
NameError
ZeroDivisionError

Expections
==========
Exception handling is the process of handling the errors that might occur in the code and avoid abrupt halt of the code. In simple English, our code should either end by performing the intended task or prints a useful message if it is not able to complete the task

Exception Handling Constructs in R
==================================
1)Try
2)Try catch

Using try
---------
We need to enclose the objectionable statements in the try block. The statements passed inside are like arguments to a function. In case you have more than one statements, it is preferred that you write a function with all those statements and call the function inside the try block

v <- list(1, 2, 4, ’0',5)
for (i in v) {
print(5/i)
}

Using the try block we can see the code ran for all the other cases even after the error in one of the iteration.

Using tryCatch
--------------
The try block will not let your code stop but does not provide any mechanism to handle the exception. By handling I mean the actions we want to perform if some error occurs in code execution.

In this case, we can use the tryCatch block to handle the exception.

We will enclose the objectionable statement in the tryCatch block and pass one more parameter to the tryCatch, error.

The error takes as input a function or an instruction and we can perform all the remedial steps to be performed in case of an error in this function.
v <- list(1, 2, 4, '0', 5)
for (i in v) {
try(print(5 / i))

Using COnditional Warning statement
-----------------------------------
Condition Signaling Functions
(or more generally Conditions in R)
In R terminology, this system is called the:
Condition System
What is a Condition in R?
Definition
A condition is a signal generated by R to communicate something important during code execution.
It may indicate:
1)An error
2)A warning
3)A message
4)A custom signal
Conditions are not normal output — they are signals.

Main Types of Conditions in R
R has three primary built-in condition types:
Condition Type	Function	Severity	Does execution continue?
Message	message()	Informational-->Yes
Warning	warning()	Caution-->Yes
Error	stop()	Critical-->No

message() — Informational Condition
What is message()?
Sends an informational signal
Used for progress, status updates
Can be suppressed

message("Data loading started")

Execution continues
Can be turned off using suppressMessages()

warning() — Warning Condition
What is warning()?
Indicates something might be wrong
Execution continues
Shown at the end of execution (by default)

warning("Missing values found")

Execution continues
Can be suppressed using suppressWarnings()

stop() — Error Condition
What is stop()?
Signals a fatal error
Execution stops immediately
Cannot be ignored

stop("Invalid input")


Execution stops
Used for enforcing rules

Why are these NOT print() or cat()?
Feature	print / cat	condition functions
Purpose	Output text	Signal events
Severity-->None-->Structured levels
Can be handled-->No-->Yes
Affect control flow-->No-->Yes

Key insight
Conditions are part of control flow, not output.

Internal Condition Classes (Important Concept)
Under the hood, R uses S3 condition classes:
Function	Condition Class

message()	"message"
warning()	"warning"
stop()	"error"

You can create custom conditions too.

Condition Handling (Advanced but Important)

R allows you to catch and handle conditions:
Try–Catch
tryCatch(
  {
    stop("Failure")
  },
  error = function(e) {
    cat("Caught error:", e$message)
  }
)

Suppressing Conditions
suppressWarnings(
  warning("This is hidden")
)

suppressMessages(
  message("This is hidden")
)

Real-World Usage Pattern
Example: Input validation
if (age < 0) {
  stop("Age cannot be negative")
}

if (age > 120) {
  warning("Age unusually high")
}

message("Age validation complete")

Common Interview Confusion (VERY IMPORTANT)
“warning() prints text”
“stop() is just an error message”

Correct understanding:
They signal conditions, not print text

One-Line Summary (Memorize This)
message(), warning(), and stop() belong to R’s Condition System and are used for signaling informational, cautionary, and error conditions during execution


Core Condition-Signaling Functions (Built-in)
These are the primary ways to signal conditions:
Function-->Condition Type-->	Stops Execution
message()-->	Message	--> No
warning()-->	Warning	--> No
stop()-->	Error	-->Yes

These three are the foundation.

Message & Warning Control Functions

These do not create conditions — they control visibility.

Function-->Purpose
suppressMessages()-->	Hide messages
suppressWarnings()-->	Hide warnings
withCallingHandlers()-->	Intercept conditions

Example:
suppressWarnings(
  warning("This will not show")
)

Error Handling & Recovery Functions

These deal with errors once they occur.

Function-->Role
try()-->	Attempt execution, continue on error
tryCatch()-->	Handle conditions explicitly
on.exit()-->	Cleanup on exit
stopifnot()	Assert conditions

Example:

stopifnot(length(x) > 0)

Informational / Diagnostic Functions
These are condition-like, but used mainly for debugging.
Function-->	What it signals
warning()-->	Risk
message()-->	Status
stop()-->	Failure
traceback()-->	Error origin
browser()-->	Pause execution
debug()-->	Step-through execution

These are part of execution diagnostics.

Custom Condition Creation (Advanced)

You can define your own condition types.

Low-level condition creators:
Function-->	Purpose
conditionMessage()-->	Extract message
conditionCall()-->	Where it happened
simpleMessage()-->	Create message object
simpleWarning()-->	Create warning object
simpleError()-->	Create error object

Example:
stop(simpleError("Custom failure"))

Restart & Recovery System (Very Advanced)
This is what makes R unique compared to Python.

Concept-->	Function
Restart	-->withRestarts()
Invoke restart	-->invokeRestart()
List restarts-->	findRestart()

This allows interactive recovery, not just failure.

Package-Level Condition Patterns (Industry Practice)

Most professional R packages use:
Purpose-->	Function
User info-->	message()
Soft validation-->	warning()
Hard validation-->	stop()
Assertions-->stopifnot()
Silent checks-->	try()

What These Are Collectively Called (Final Answer)

All of these belong to:
-->R’s Condition System and more broadly:

Error & Condition Handling Framework
Mental Model (Important)
Think of R execution as:
Run code-->
  message -->inform
  warning-->caution
  ├─ error → stop
  ├─ handler → recover
  └─ restart → continue differently

One-Line Interview Answer
Yes. In addition to message(), warning(), and stop(), R provides a full Condition System including condition handlers
(tryCatch, withCallingHandlers), suppression functions, custom conditions, and restart mechanisms

Quiz:
=====

Assignment:
===========
1-Handle the exception thrown by the code below by using try and except blocks.
	for i in ['a','b','c']:
	    print(i**2)
2-Handle the exception thrown by the code below by using try and except blocks. Then use a finally block to print 'All Done.'
	x = 5
	y = 0
	z = x/y
3-Write a function that asks for an integer and prints the square of it. Use a while loop with a try, except, else block to account for incorrect inputs(it need to ask again and again if there is a wrong input)
	def ask():
	    pass 

Resources
=========
https://www.geeksforgeeks.org/handling-errors-in-r-programming/
https://www.r-bloggers.com/2012/10/error-handling-in-r/
https://medium.com/analytics-vidhya/error-handling-in-r-23b22d82fa6f
https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781784390815/1/ch01lvl1sec18/handling-errors-in-a-function